% A LaTeX file that describes technical details in ALE, including protocols and compiling.

\documentclass[12pt]{article}

\usepackage{hyperref}
\usepackage{fullpage}

\title{Arcade Learning Environment\\ Technical Manual (v.0.5.0)}
\author{}

\begin{document}

\maketitle

\clearpage

\tableofcontents

\clearpage

\section{Overview}

This document describes how to install the Arcade Learning Environment as well as how to use it.
We will present the different ways to implement an agent: 
\begin{enumerate}
  \item \textbf{Shared Library interface} (C++): Loads ALE as a shared library (Section 
  \ref{sec:shared_library_interface}).}
  \item \textbf{CTypes interface} (Python): Uses the ALE as an external Python library, 
  allowing one to write ALE code by just importing the correspondent library. This is a very
  fast interface (Section \ref{sec:python_interface}).
  \item \textbf{RL-Glue interface} (C/C++, Java, Python, Matlab or Lisp): Communicates
  with ALE via RL-Glue (Section \ref{sec:rlglue_interface}).}
  \item \textbf{FIFO interface} (any language): Communicates with ALE through a text interface 
  using \verb+stdin/stdout+ (Section \ref{sec:pipes_interface}).}.
\end{enumerate}

We also discuss some sensible features of this environment, such as its stochasticity.

\section{Installing}\label{sec:install}

\subsection{Requirements}

The basic requirements to build and run the ALE are:
\begin{itemize}
  \item \verb+CMake / make / g+++
\end{itemize}
Notice that in the past (previous to version 0.5.0) the recommended method to compile the ALE was
through Makefiles written by the ALE developers. This has changed and now we suggest everyone to
use CMake to generate a Makefile and then to compile the code using such generated Makefile. The
old Makefiles written for Linux and OS X (files \verb+makefile.mac+ and \verb+makefile.unix+) are
still available, but we do not support them anymore.

The ALE provides some functionalities that are not activated by default, but if chosen the user is 
required to use additional packages:
\begin{itemize}
  \item \verb+SDL / RL-Glue+
\end{itemize}

\subsection{Installation/Compilation}

One first has to install the ALE requirements before compiling the ALE itself. Assuming that 
\verb+g+++ and \verb+make+ are already available to the user, to install CMake and SDL is 
straightforward, and it can be done through package managers in both OS X and Linux:

\subsubsection*{OS X:}
\begin{verbatim}
  > brew install cmake
  > brew install sdl
\end{verbatim}

\subsubsection*{Linux (e.g.: Ubuntu):}
\begin{verbatim}
  > sudo apt-get install cmake
  > sudo apt-get install libsdl1.2-dev
\end{verbatim}

To install RL-Glue, in both systems, we recommend the user to go to the RL-Glue 
webpage\footnote{\url{http://glue.rl-community.org/wiki/Main_Page}} and to follow
the presented instructions.

We are going to assume the ALE was extracted to \verb+ale_0_5+. Then, compiling it
with CMake is very simple (in both systems):
\begin{verbatim}
  > cd ale_0_5
  ale_0_5> cmake .
  ale_0_5> make -j4
\end{verbatim}

This compiles the code without SDL and RL-Glue. If one wants to compile ALE with such libraries it 
is enough to change such flags in the file \verb+ale_0_5/CMakeLists.txt+. More specifically, lines
3 and/or 4 have to be changed (by replacing the word \verb+OFF+ by \verb+ON+ in the
correspondent line):

\begin{verbatim}
  option(USE_SDL "Use SDL" OFF)
  option(USE_RLGLUE "Use RL-Glue" OFF)
\end{verbatim}

Due to different operational systems and installed libraries, some errors mainly related to the SDL 
paths being wrong have been reported. If you face such issues please look at 
Section~\ref{sec:troubleshooting}.

\section{Implementing an agent in C++ (with shared libraries)}

If one wants to implement an agent in C++, the best approach is to use the ALE shared library. 
The shared library interface allows agents to directly access ALE via a class called
\verb+ALEInterface+, defined in \verb+ale_interface.hpp+. We are going to discuss here, 
step-by-step how to implement an agent that plays randomly. A code containing an example is
available at \verb+doc/examples/sharedLibraryInterfaceExample.cpp+.

This example is automatically compiled with the ALE when following the steps presented in
Section~\ref{sec:install}. If one wants to disable such an option it is enough to replace \verb+ON+ 
by \verb+OFF+ in the line below, present in file \verb+ale_0_5/CMakeLists.txt+:

\begin{verbatim}
  option(BUILD_EXAMPLES "Build Example Agents" ON)
\end{verbatim}

To implement an agent, the first step is to include the library \verb+ale_interface.hpp+, either via 
the relative path \verb+#include ``path/from/your/code/ale_interface.hpp''+, or as a standard 
header: \verb+#include <ale_interface.hpp>+. If the later is chosen, remember to add the proper 
path using the flag \verb+-I+ when compiling the code.

To instantiate the Arcade Learning Environment it is enough to do:\\

\verb+ALEInterface ale;+\\

Once the environment is initialized, it is now possible to set its arguments. This is done with the 
functions \verb+setBool(), setInt(), setFloat()+. The complete list of flags is available in 
Section~\ref{sec:arguments}. Just as an example, if one wants to set the environment's seed he must 
do:\\

\verb+ale.setInt("random_seed", 123);+\\

After setting all variables we can now load the game ROM:\\

\verb+ale.loadROM(asterix.bin /*rom name*/);+\\

There are two different sets of actions in the ALE: the ``legal'' action set and the ``minimal'' 
action set. The legal action set consists of 18 actions regardless of the game, therefore, some 
actions may not have an effect on that game. On the other hand, the minimal action set contains only 
the actions that do have some effect on that game. To obtain such list of actions one has to call, for
example:\\

\verb+ActionVect legal_actions = ale.getLegalActionSet();+\\

Then, to act one can call the function \verb+act()+ passing an object of \verb+Action+ as parameter:\\

\verb+Action a = legal_actions[rand() % legal_actions.size()];+\\
\indent \verb+float reward = ale.act(a);+\\

Finally, one can check if the game is over using the function \verb+ale.game_over()+. With these 
functions one can already implement a very simple agent that plays randomly once:

\begin{verbatim}
#include <iostream>
#include <ale_interface.hpp>

using namespace std;

int main(int argc, char** argv) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " rom_file" << std::endl;
        return 1;
    }

    ALEInterface ale;
    ale.setInt("random_seed", 123);
    ale.loadROM(argv[1]);

    ActionVect legal_actions = ale.getLegalActionSet();
    
    float totalReward = 0;
    while (!ale.game_over()) {
        Action a = legal_actions[rand() % legal_actions.size()];    
        float reward = ale.act(a);
            totalReward += reward;
        }
        cout << "The episode ended with score: " << totalReward << endl;
    }
    return 0;
}
\end{verbatim}

Recall this is a very simple example using the ALE. It is also important to remember to use the flag 
\verb+-L+ to link the ALE library. Also, to run the agent, you may need to add ALE to your library
path:

\begin{verbatim}
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/ale_0_5
\end{verbatim}

or under Mac OS X,

\begin{verbatim}
export DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH:/path/to/ale_0_5
\end{verbatim}

As a final remark, a complete list of functions available in the class \verb+ALEInterface+ is 
presented in Section~\ref{sec:functions}.

\section{Python Interface}\label{sec:python_interface}

To use the Python interface it is necessary to install it after the ALE was compiled. If one has 
root access to the machine it is enough to run:\\

\verb+pip install .+\\

otherwise, if he does not have root access, the following should work:\\

\verb+pip install --user .+\\

Then, to use it in a Python code it is enough to import it properly, for example, as in the 
example below (\verb+from ale_python_interface import ALEInterface+). A code containing
an example is available at \verb+doc/examples/python_example.py+.

All the functions are the same as in the C++ interface. Therefore, it is pointless to discuss all
functions again. A complete example in Python is below:

\begin{verbatim}
import sys
from random import randrange
from ale_python_interface import ALEInterface

if len(sys.argv) < 2:
  print 'Usage:', sys.argv[0], 'rom_file'
  sys.exit()

ale = ALEInterface()
ale.setInt('random_seed', 123)
ale.loadROM(sys.argv[1])

# Get the list of legal actions
legal_actions = ale.getLegalActionSet()

total_reward = 0
while not ale.game_over():
  a = legal_actions[randrange(len(legal_actions))]
  reward = ale.act(a);
  total_reward += reward
print 'Episode ended with score:', total_reward
\end{verbatim}

\section{FIFO Interface}\label{sec:pipes_interface}

The FIFO interface is text-based and allows the possibility of run-length encoding the screen. This section documents the actual protocol used; sample code implementing this protocol in Java is also included in this release.

After preliminary handshaking, the FIFO interface enters a loop in which ALE sends information about the current time step and the agent responds with both players' actions (in general agents will only control the first player). The loop is exited when one of a number of termination conditions occurs.

\subsection{Handshaking}

ALE first sends the width and height of its screen matrix as a hyphen-separated string:

\begin{verbatim}
www-hhh\n
\end{verbatim}

where \verb+www+ and \verb+hhh+ are both integers.

The agent then responds with a comma-separated string:

\begin{verbatim}
s,r,k,R\n
\end{verbatim}

where \verb+s+, \verb+r+, \verb+R+ are 1 or 0 to indicate that ALE should or should not send, at every time step, screen, RAM and episode-related information (see below for details). The third argument, \verb+k+, is deprecated and currently ignored.

\subsection{Main Loop -- ALE}

After handshaking, ALE will then loop until one of the termination conditions occurs; these conditions are described below in Section \ref{subsec:termination_conditions}. If terminating, ALE sends

\begin{verbatim}
DIE\n
\end{verbatim}

Otherwise, ALE sends

\begin{verbatim}
<RAM_string><screen_string><episode_string>\n
\end{verbatim}

Where each of the three strings is either the empty string (if the agent did not request this
particular piece of information), or the relevant data terminated by a colon.

\subsubsection{\texttt{RAM\_string}}

The RAM string is 128 2-digit hexadecimal numbers, with the $i^{th}$ pair denoting the
$i^{th}$ byte of RAM; in total this string is 256 characters long, not including the terminating
`:'.

\subsubsection{\texttt{screen\_string}}

In ``full'' mode, the screen string is \texttt{www} $\times$ \texttt{hhh} 2-digit hexadecimal numbers, each representing a pixel. Pixels are sent row by row, with \texttt{www} characters for each row. In total this string is 2 $\times$ \texttt{www} $\times$ \texttt{hhh} characters long.

In run-length encoding mode, the screen string consists of a variable number of (colour,length) pairs denoting a run-length encoding of the screen, also row by row. Both colour and length are described using 2-digit hexadecimal numbers. Each pair indicates that the next `length' pixels take on the given colour; run length is thus limited to 255. Runs may wrap around onto the next row. The encoding terminates when the last pixel (i.e. the bottom-right pixel) is encoded. The length of this string is 4 characters per (colour,length) pair, and varies depending on the screen.

In either case, the screen string is terminated by a colon.

\subsubsection{\texttt{episode\_string}}

The episode string contains two comma-separated integers indicating episode termination (1 for
termination, 0 otherwise) and the most recent reward. It is also colon-terminated.

\subsubsection{Example}

Assuming that the agent requested screen, RAM and episode-related information, a string sent by ALE might look like:

\begin{verbatim}
000100...A401B2:3C3C3C3C00003C3C3C...4F4F0000:0,1:\n
^ 2x128 characters   ^ 2x160x210 characters    ^ongoing episode, reward of 1
\end{verbatim}

\subsection{Main Loop -- Agent}

After receiving a string from ALE, the agent should now send the actions of player A and player B.
These are sent as a pair of comma-separated integers on a single line, e.g.:

\begin{verbatim}
2,18\n
\end{verbatim}

where the first integer is player A's action (here, \textsc{fire}) and the second integer, player B's action (here, \textsc{noop}). Emulator control (reset, save/load state) is also handled by sending a special action value as player A's action. See Section \ref{sec:available_actions} for the list of available actions.

\subsection{Termination}\label{subsec:termination_conditions}

ALE will terminate (and potentially send a \verb+DIE+ message to the agent) whe one of the following conditions occur:

\begin{itemize}
  \item{\texttt{stdin} is closed, indicating that the agent is no longer sending data, or}
  \item{The maximum number of frames (user-specified, with no maximum by default) has been reached.}
\end{itemize}

ALE will send an end-of-episode signal when one the following is true:

\begin{itemize}
  \item{The maximum number of frames for this episode (user-specified, with no maximum by default) has been reached, or}
  \item{The game has ended, usually when player A loses their last life.}
\end{itemize}

\section{RL-Glue Interface}\label{sec:rlglue_interface}

The RL-Glue interface implements the RL-Glue 3.0 protocol.
It requires the user to first install the RL-Glue core. Additionally, the example agent and 
environment require the RL-Glue C/C++ codec. Both of these can be found on the RL-Glue web
site\footnote{http://glue.rl-community.org}.

In order to use the RL-Glue interface, ALE must be compiled with RL-Glue support. This is achieved
by setting \verb+option(USE_RLGLUE "Use RL-Glue" ON)+ in the CMakeListst.txt file.

Specifying the command-line argument \verb+-game_controller rlglue+ is sufficient to put ALE in 
RL-Glue mode. It will then communicate with the RL-Glue core like a regular RL-Glue environment.

\subsection{Sample Agent and Experiment}

Example source code can be found under

\begin{verbatim}
ale_0_4/doc/examples
\end{verbatim}

Assuming you installed ALE under \verb+/path/to/ale_0_5+, the RL-Glue agent and experiment
can be compiled with the following command: 

\begin{verbatim}
make rlglueAgent 
\end{verbatim}

As with any RL-Glue application, you will need to start the following processes to run the
sample RL-Glue agent in ALE:

\begin{itemize}
  \item{\verb+rl_glue+} 
  \item{\verb+RLGlueAgent+}
  \item{\verb+RLGlueExperiment+}
  \item{\verb+ale+ (with command-line argument \verb+-game_controller rlglue+)}
\end{itemize}

Please refer to the RL-Glue documentation for more details. 


\subsection{Actions and Observations}

The action space consists of both Player A and Player B's actions (see Section 
\ref{sec:available_actions}
for details). In general, Player B's action may safely be set to noop (18) but it should be left out
altogether if the \verb+-restricted_action_set+ command--line argument was set to true. 

The observation space depends on whether the \verb+-send_rgb+ argument was passed to ALE. If it was
not passed,  or it was set to false, the observation space consists of 33,728 integers: first the
128 bytes of RAM (taking values in 0-- 255), then the 33,600 screen pixels (taking value in 0--127).
The screen is provided in row-order, i.e. beginning with the 160 pixels that compose the first row.

 If \verb+-send_rgb+ was set to true on the command-line, the observation space consists of 100,928 
 integers: first the same 128 bytes of RAM, followed by 100,800 bytes describing the screen.
 Each pixel is described by three bytes, taking values from 0--255, specifying the pixel's 
 red, green and blue components in that order. The pixel order is the same as in the default
 case.

\section{Environment Specifications}\label{sec:environment_specifications}

This section provides additional information regarding the environment implemented in ALE.

\subsection{Available Actions}\label{sec:available_actions}

The following regular actions are defined in \verb+common/Constants.h+ and interpreted by ALE:

\begin{center}
\begin{tabular}{|r|r|r|r|r|}
\hline
noop (0) & fire (1) & up (2) & right (3) & left (4) \\
\hline
down (5) & up-right (6) & up-left (7) & down-right (8) & down-left (9) \\
\hline
up-fire (10) & right-fire (11) & left-fire (12) & down-fire (13) & up-right-fire (14) \\
\hline
up-left-fire (15) & down-right-fire (16) & down-left-fire (17) & reset* (40) & \\
\hline
\end{tabular}
\end{center}

Note that the \verb+reset+ (40) action toggles the Atari 2600 switch, rather than reset the 
environment, and as such is ignored by most interfaces.
In general it should be replaced by either a call to \verb+StellaEnvironment::reset+ or by
sending the \verb+system_reset+ command, depending on the interface. 

Player B's actions are the same as those of Player A, but with 18 added. For example, Player B's
up action corresponds to the integer 20.

In addition to the regular ALE actions, the following actions are also processed by the 
FIFO interfaces:

\begin{center}
\begin{tabular}{|r|r|r|r|r|}
\hline
save-state (43) & load-state (44) & system-reset (45) \\
\hline
\end{tabular}
\end{center}

\subsection{Terminal States}

Once the end of episode is reached (a terminal state in RL terminology), no further emulation 
takes place until the appropriate reset command is sent. This command is distinct from the Atari 
2600 reset. This ``system reset'' avoids odd situations where the player can reset the game
through button presses, or where the game normally resets itself after a number of frames. This 
makes for a cleaner environment interface. With the exception of the RL-Glue interface, which 
automatically resets the environment, the interfaces described here all provide a system reset
command or method.

\subsection{Saving and Loading States}

State saving and loading operates in a stack-based manner: each call to save stores the current
environment state onto a stack, and each call to load restores the last saved copy and removes
it from the stack. The ALE 0.2 save/load mechanism, provided for backward compatibility, instead
overwrites its saved copy when a save is requested. When loading a state, the currently saved copy
is preserved.

\subsection{Colour Averaging}

Many Atari 2600 games display objects on alternating frames (sometimes even less frequently).
This can be an issue for agents that do not consider the whole screen history. By default, 
\emph{colour averaging} is not enabled. If enabled, the environment output (as observed by agents)
is going to be a weighted blend of the last two frames. This behaviour can be turned on using the
command-line argument \verb+-color_averaging+ (or the \verb+setBool+ function).

\subsection{Randomness}

The Atari 2600 games, as emulated by Stella, are deterministic. However, previous works have shown 
that it is of interest to add stochasticity to this domain, to avoid the exploration of open loop 
planning (trajectory optimization), \emph{i.e.} to prevent agents from simply learning a trajectory by
rote. 

Such stochasticity is implemented in the ALE through the performed actions. With a probability $p$ 
the previous executed action is going to be executed in the next frame, regardless of the current 
requested action. $p$ has a default value of $0.25$. The motivation of this implementation is to 
resemble how humans play games. Humans are not capable of being extremely precise regarding which 
frame they will take an action. Because of that we thought it would be a reasonable approach to 
implement stochasticity in such a way.

Also,  it is important to stress that we have added TinyMT as the random number generator. This was 
made to avoid any sort of problem one could have by overriding the environment's seed with later 
calls (this can happen with \verb+rand()/srand()+). In practice this has no effect to those using
the ALE, but it is important to stress such feature.

\subsection{Minimal Action Set}

It may sometimes be convenient to restrict the agent to a smaller action set. This can be
accomplished by querying the \verb+RomSettings+ class using the method 
\verb+getMinimalActionSet+. This then returns a set of actions judged ``minimal'' to play a given
game. Of course, algorithm designers are encouraged to devise algorithms that don't depend 
on this minimal action set for success.

\section{Miscellaneous}

This section provides additional relevant ALE information.

\subsection{Displaying the Screen}\label{subsec:displaying_screen}

ALE offers screen display and audio capabilities via the Simple DirectMedia Layer (SDL).
This requires the following libraries:

\begin{itemize}
  \item{\textbf{libsdl}}
  \item{\textbf{libsdl-gfx}}
  \item{\textbf{libsdl-image}}
\end{itemize}

To compile with SDL support, you should change the file \verb+CMakeLists.txt+, replacing
the word \verb+OFF+ by \verb+ON+ in the line \verb+option(USE_SDL "Use SDL" OFF)+.
Then, screen display can be enabled with the \verb+display_screen+ argument (command line
or function \verb+setBool+). 

SDL support has been tested under Linux and Mac OS X. 

\subsection{Recording Movies}

ALE now contains support for recording frames and sound via SDL (Section \ref{subsec:displaying_screen}).
An example C++ program is provided which will record a single episode of play. This program is located at

\begin{center}
\texttt{doc/examples/videoRecordingExample.cpp}
\end{center}

Compiling and running this program will create a directory \texttt{record}\footnote{The example program creates this directory, using a system call to \texttt{mkdir}. If this fails on your machine, you will need to manually create this directory.} in which frames will be saved sequentially and named according to their frame numbers. Thus, if the episode lasts 683 frames then the files \verb+record/000000.png+ to \verb+record/000682.png+ are created. Furthermore, sound output is also recorded as \verb+record/sound.wav+. The following flags control recording behaviour:

\small{
\begin{verbatim}
  -display_screen <true|false> -- should be set to true for recording
    default: false
  -sound <true|false> -- whether to enable sound output
    default: false
  -record_screen_dir -- path to record screens; if empty, no recording occurs
    default: ""
  -record_sound_filename -- path to single wav file to be recorded; 
            if empty, no recording occurs
    default: ""
\end{verbatim}
}

Once frames and/or sound have been recorded, they may be joined into a movie file using the external program \texttt{ffmpeg} (installable on Mac OS X and most *nix OSes through a package manager). For your convenience, two example scripts are provided:

\begin{itemize}
    \item{\texttt{doc/scripts/videoRecordingExampleJoinMacOSX.sh}}
    \item{\texttt{doc/scripts/videoRecordingExampleJoinUnix.sh}}
\end{itemize}

These should be run from the same directory that the C++ example was run from. Unfortunately \texttt{ffmpeg} is a complicated beast and taming it may require tweaking specific to your system configuration. Please contact us if you would like to provide an example script for a different configuration.

Here is a full, step-by-step example on Mac OS X (after building the project):
\begin{verbatim}
> cd ale_0_4
ale_0_4> doc/examples/videoRecordingExample space_invaders.bin

A.L.E: Arcade Learning Environment (version 0.4.4)
[Powered by Stella]

[ usual ALE output ]

Recording screens to directory: record

Recording complete. See manual for instructions on creating a video.

ale_0_4> doc/scripts/videoRecordingExampleJoinMacOSX.sh

ffmpeg version 2.6.1 Copyright (c) 2000-2015 the FFmpeg developers
  built with Apple clang version 4.1 (tags/Apple/clang-421.11.65) ... 

[ loads of output ]

ale_0_4> open agent.mov
\end{verbatim}

\section{Troubleshooting / FAQ} \label{sec:troubleshooting}

Where are the ROMS?

We do not provide them due to copyrights.

\section{ALE Interface Specifications}\label{sec:functions}

Below are listed the functions available in the ALE interface with the description of their 
behavior. The functions were divided in different sections to make the presentation more
clear.

  \subsection{Initialization}

  \indent \indent \verb+ALEInterface(bool display_screen)+: ALE constructor. If the 
  \verb+display_screen+ parameter is set to \verb+true+, and the ALE was compiled
  with SDL, the game display will be presented. If set to \verb+false+ one will not see
  the game being played.
  
  \verb+void loadROM(string rom_file)+: Resets the ALE and then loads a game. After this call
  the game should be ready to play. If one changes (or sets) a setting (Section~\ref{sec:getSet}), 
  it is necessary to call this function after the change so it can take effect.
  
  \subsection{Parameters setting and retrieval}\label{sec:getSet}
  
  \indent \indent \verb+string getString(const string& key)+: Get the value of any flag passed
  as parameter that has a string value; \emph{e.g.}: \verb+getString(``record_sound_filename'')+.

  \verb+int getInt(const string& key)+: Get the value of any flag passed as parameter that has 
  an integer value; \emph{e.g.}: \verb+getInt(``frame_skip'')+.

  \verb+bool getBool(const string& key)+: Get the value of any flag passed as parameter that has 
  a boolean value; \emph{e.g.}: \verb+getBool(``restricted_action_set'')+. 
  
  \verb+float getFloat(const string& key)+: Get the value of any flag passed as parameter that has 
  a float value; \emph{e.g.}: \verb+getBool(``repeat_action_probability'')+.   
  
  \verb+void setString(const string& key, const string& value)+: Set the value of any flag
  that has a string type; \emph{e.g.}: \verb+setString("random_seed", "time")+.
  \verb+loadRom()+ must be called before the setting will take effect.
  
  \verb+void setInt(const std::string& key, const int value)+: Set the value of any flag
  that has an integer type; \emph{e.g.}: \verb+setInt("frame_skip", 1)+. \verb+loadRom()+
  must be called before the setting will take effect.
  
  \verb+void setBool(const std::string& key, const bool value)+: Set the value of any flag
  that has a boolean type; \emph{e.g.}: \verb+setBool("restricted_action_set", false)+.
  \verb+loadRom()+ must be called before the setting will take effect.
  
  \verb+void setFloat(const std::string& key, const float value)+: Set the value of any flag
  that has a float type; \emph{e.g.}: \verb+setFloat("repeat_action_probability", 0.25)+.
  \verb+loadRom()+ must be called before the setting will take effect.
  
  \subsection{Acting and Perceiving}
  
  \indent \indent \verb+reward_t act(Action action)+: Applies an action to the game and returns the
  reward. It is the user's responsibility to check if the game has ended and reset when necessary
  (this method will keep pressing buttons on the game over screen).
  
  \verb+bool game_over()+: Indicates if the game has ended.
  
  \verb+void reset_game()+: Resets the game, but not the full system (it is not ``equivalent''
  to  unplug the console from electricity).
  
  \verb+ActionVect getLegalActionSet()+: Returns the vector of legal actions (all the 18 actions).
  This should be called only after the ROM is loaded.
  
  \verb+ActionVect getMinimalActionSet()+: Returns the vector of the minimal set of actions
  needed to play the game (all actions that have some effect on the game). This should be
  called only after the ROM is loaded.
  
  \verb+int getFrameNumber()+: Returns the current frame number since the loading of the ROM.
  
  \verb+const int lives()+: Returns the agent's remaining number of lives. If the game does not have 
  the concept of lives (\emph{e.g.} \textsc{Freeway}), this function returns 0.
  
  \verb+int getEpisodeFrameNumber()+: Returns the current frame number since the start of the
  current episode.
  
  \verb+const ALEScreen &getScreen()+: Returns a matrix containing the current game screen.
  
  \verb+const ALERAM &getRAM()+: Returns a vector containing current RAM content (byte-level).
  
  \verb+void saveState()+: Saves the current state of the system if one wants to be able to recover 
  a state in the future; \emph{e.g.} in search algorithms.
  
  \verb+void loadState()+: Loads a previous saved state of the system once we have a state saved.

  \subsection{Recording trajectories}
   
  \indent \indent \verb+void saveScreenPNG(const string& filename)+: Saves the current screen as
  a \verb+png+ file.
  
  \verb+ScreenExporter *createScreenExporter(const string &path) const+: Creates a 
  ScreenExporter object which can be used to save a sequence of frames. Frames are saved 
  in the directory 'path', which needs to exists. This is used to generate movies depicting the behavior
  of agents.

\section{Command-line Arguments}\label{sec:arguments}

Command-line arguments are passed to ALE before the ROM filename. The current version removed all 
the internal agents in the game, therefore, the command-line arguments are mostly useful to start 
the communication when using FIFO pipes.

However, these parameters can also be set when using the C++ or Python interface, for example. In 
this case, they are set using those functons discussed in Section~\ref{sec:getSet}. The configuration file 
\verb+ale_0_5/stellarc+ can also be used to set frequently used command-line arguments.  

The parameters that can be set are all listed below.

\subsection{Main Arguments}
\small{
\begin{verbatim}

  -help -- prints out help information

  -game_controller <fifo|fifo_named|rlglue> -- selects an ALE interface
    default: unset

  -random_seed <###|time> -- picks the ALE random seed, or sets it to current time
    default: time

  -display_screen <true|false> -- if true and SDL is enabled, displays ALE screen
    default: false
    
  -sound  <true|false> -- if true and SDL is enabled, the game will have game
    sounds  enabled
    default: false


\end{verbatim}
}

\subsection{Environment Arguments}

\small{
\begin{verbatim}

  -max_num_frames ### -- max. total number of frames, or 0 for no maximum 
    (it is not available in the shared library interface, i.e. to be set 
    by C++  or Python code directly linking to the shared library)
    default: 0

  -max_num_frames_per_episode ### -- max. number of frames per episode
    default: 0

  -frame_skip ### -- frame skipping rate; 1 indicates no frame skip 
    default: 1

  -color_averaging <true|false> -- if true, enables colour averaging 
    default: false

  -record_screen_dir [save_directory] -- saves game screen images to
    save_directory
     
  -repeat_action_probability -- stochasticity in the environment. It is the
    probability the previous action will repeated without executing the new
    one
    default: 0.25
\end{verbatim}
}

\subsection{FIFO Interface Arguments}

\small{
\begin{verbatim}
  -run_length_encoding <true|false> -- if true, encodes data using run-length
    encoding
    default: true
\end{verbatim}
}

\subsection{RL-Glue Interface Arguments}

\small{
\begin{verbatim}
  -send_rgb <true|false> -- if true, RGB values are sent for each pixel
    instead of the pallette index values
    default: false
    
  -restricted_action_set <true|false> -- if true, agents use a smaller set of 
    actions (RL-Glue interfaces only)
    default: false    
\end{verbatim}
}

\end{document}
